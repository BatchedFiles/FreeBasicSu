<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"[

	<!ENTITY nbsp "&#160;">
	<!ENTITY t "&#160;&#160;&#160;&#160;">
	
]>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

<head>
	<title>Интерфейсы в COM</title>
	<meta name="description" content="Как создавать COM‐совместимые интерфейсы и использовать их в своих программах" />
	<meta name="keywords" content="Interface, COM, ActiveX" />
	
	<link href="/styles.css" type="text/css" rel="stylesheet" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	
</head>

<body>

<header>
	
	<nav>
		<p><a href="/">Главная</a></p>
		<p><a href="/articles/">Статьи</a></p>
		<p><a href="/tags/">Рубрики</a></p>
		<p><a href="/books/">Учебник</a></p>
		<!-- <p><a href="/tasks/">Задачи</a></p> -->
		<p><a href="/projects/">Проекты</a></p>
		<p><a href="/users/">Пользователи</a></p>
		<p><a href="/help/">Информация</a></p>
	</nav>
	
</header>

<h1>Интерфейсы в COM</h1>

<main>
	<p class="postername">
		<a href="/users/mabu.xhtml">
			<img src="/avatars/mabu.jpg" alt="Аватар пользователя" width="50" height="50" class="avatar" />
			&#32;
			mabu
		</a>
		&#32;
		<time pubdate="pubdate">2016-02-10T09:25:31+07:00</time>
	</p>
	
	<p>COM — это метод разработки программных компонентов, небольших двоичных исполняемых файлов, которые предоставляют необходимые функции приложениям, операционным системам и другим компонентам. Разработка компонента COM основана на разработке интерфейсов и реализации интерфейсов. Компоненты COM объединяются друг с другом для создания приложений или систем компонентов. Компоненты можно отключать и менять во время выполнения, без перекомпиляции или перекомпоновки приложения. Концепция придумана как решение проблемы взаимодействия программ, написанных на совершенно разных языках программирования и разных операционных системах.</p>
	
	<p>COM в качестве решения этой проблемы использует указатель на интерфейс: всё, что нужно для работы с объектом — это получить указатель на его интерфейс, и ничего более. Этот указатель представляет собой «чёрный ящик», ссылку на данные, о содержимом которых программисту знать не нужно.</p>
	
	<ol class="contents">
		<li><a href="#c1">Интерфейс IUnknown</a>
			<ol>
				<li><a href="#c1c1">Первая подглава</a></li>
				<li><a href="#c1c2">Вторая подглава</a></li>
				<li><a href="#c1c3">Третья подглава</a></li>
			</ol>
		</li>
		<li><a href="#c2">Вторая глава</a></li>
		<li><a href="#c3">Третья глава</a></li>
	</ol>
	
	<h2>Жизнь COM‐интерфейсов</h2>
	
	<p>В СОМ интерфейсы — это всё. Для клиента компонент представляет собой набор интерфейсов. Клиент может взаимодействовать с компонентом СОМ только через интерфейс. Компоненты сами по себе есть просто детали реализации интерфейсов.</p>
	
	<p>Один из наиболее шокирующих моментов COM — это то, что интерфейсы не изменяются, причём не изменяются никогда. После того, как интерфейс опубликован, он обязан быть всегда тем же самым, а при модификации компонента создают новый интерфейс.</p>
	
	
	<h3>Где обитают интерфейсы</h3>
	
	<p>Интерфейсы сами по себе летают в многомерных пространствах порядка и хаоса идеального мира, а их материальные воплощения живут во вполне конкретных местах на твоём компьютере: в динамически подключаемых библиотеках <code>*.dll</code> либо в исполняемых файлых <code>*.exe</code>.</p>
	
	<p>Интерфейсы — это чистая абстракция, существующая только в исходном тексте программы. Но центральный процессор работает не с абстракциями и текстом, а с инструкциями и конкретными данными, поэтому для использования интерфейсов создают реализующие их классы. Класс может реализовать как один, так и множество интерфейсов, а в библиотеку классов можно поместить от одного до множества классов.</p>
	
	<h2>Идентификация интерфейсов</h2>
	
	<p>В некоторых языках программирования для объявления интерфейсов есть ключевое слово <code>Interface</code>, некоторые языки эмулируют интерфейсы через абстрактные классы и чисто виртуальные функции, другие — через записи, структуры или пользовательские типы данных. Так как по правилам COM требуется независимость от языка программирования, то нужно было ввести единый свод правил, помогающий однозначно идентифицировать конкретный интерфейс.</p>
	
	<h3>UUID</h3>
	
	<p>Как‐то в один прекрасный день корпорация Open Software Foundation придумала концепцию UUID — Universally Unique Identifier, вселенски уникального идентификатора. Она взяла 128‐битное число и написала для его вычисления специальный алгоритм, более‐менее равномерно выдающий значения из такого огромного диапазона. Из‐за того, что само число очень большое, вероятность выдачи алгоритмом двух одинаковых чисел невелика. На практике можно говорить, что любое новое число UUID будет уникально.</p>
	
	<h3>GUID</h3>
	
	<p>Корпорация Microsoft взяла на вооружение эту мысль и число UUID без изменения, только назвала его немного по‐другому: GUID, то есть Globally Unique Identifier, глобально уникальный идентификатор.</p>
	
	<p>Microsoft применяет GUID в качестве идентификаторов для классов (CLSID — Class Identifier), интерфейсов (IID — Interface Identifier), библиотек типов (LIBID — Library Identifier).</p>
	
	<p>В тексте GUID записывается в виде строки из тридцати двух шестнадцатеричных цифр, разбитой на группы дефисами и опционально окружённой фигурными скобками. Ты уже наверняка где‐нибудь встречал похожие записи GUID:</p>
	
	<p class="codebox"><span>Код</span> <span>Простой текст</span><br /><code>
		{90125688-9C3F-4E6F-8D96-A8C71B8251E0}<br />
		{6F9619FF-8B86-D011-B42D-00CF4FC964FF}<br />
		{717473E7-54B3-4580-A086-2199430834DA}<br />
		{4C9E6590-A9C5-40AD-9E13-AB55F6AAC05F}
	</code></p>
	
	<h3>Объявление GUID</h3>
	
	<p>В заголовочном файле <code>guiddef.bi</code> GUID, IID (идентификатор интерфейса) и CLSID (идентификатор класса) объявляются в виде структур и дополнительных имён так:</p>
	
	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="keyword">Type</span> <span class="datatype">_GUID</span><br />
			&t;Data1 <span class="keyword">As</span> <span class="datatype">ULong</span><br />
			&t;Data2 <span class="keyword">As</span> <span class="datatype">UShort</span><br />
			&t;Data3 <span class="keyword">As</span> <span class="datatype">UShort</span><br />
			&t;Data4(0 <span class="keyword">To</span> 7) <span class="keyword">As</span> <span class="datatype">UByte</span><br />
		<span class="keyword">End Type</span><br />
		<br />
		<span class="keyword">Type</span> <span class="datatype">GUID</span> <span class="keyword">As</span> <span class="datatype">_GUID</span><br />
		<span class="keyword">Type</span> <span class="datatype">IID</span> <span class="keyword">As</span> <span class="datatype">GUID</span><br />
		<span class="keyword">Type</span> <span class="datatype">CLSID</span> <span class="keyword">As</span> <span class="datatype">GUID</span>
	</code></p>
	
	<p>Как видно, GUID — это дополнительное имя для структуры _GUID, а CLSID и IID — это дополнительные имена для GUID.</p>
	
	<p>В исходном коде объявлять переменную типа GUID можно через длинный ряд шестнадцатеричных чисел. Посмотрим как объявляется IID интерфейса <code>IXmlHttpRequest</code> и CLSID класса <code>XmlHttpRequest</code>, который его реализует:</p>
	
	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="keyword">Dim</span> CLSID_XMLHTTPREQUEST <span class="keyword">As</span> <span class="datatype">CLSID</span> = <span class="keyword">Type</span>(&amp;hED8C108E, &amp;h4349, &amp;h11D2, _<br />
			&t;{&amp;h91, &amp;hA4, &amp;h00, &amp;hC0, &amp;h4F, &amp;h79, &amp;h69, &amp;hE8})<br />
		<br />
		<span class="keyword">Dim</span> IID_IXmlHttpRequest <span class="keyword">As</span> <span class="datatype">IID</span> = <span class="keyword">Type</span>(&amp;hED8C108D, &amp;h4349, &amp;h11D2, _<br />
			&t;{&amp;h91, &amp;hA4, &amp;h00, &amp;hC0, &amp;h4F, &amp;h79, &amp;h69, &amp;hE8})
	</code></p>
	
	<h3>ProgID</h3>
	
	<p>Корпорация Microsoft посчитала, что запоминать все GUID для классов — это неудобно, и ввела программный идентификатор ProgID. Такой идентификатор представляет собой читаемую строку, определяющую класс. На формат ProgID не накладываются ограничения, поэтому он не может однозначно определять класс, однако ProgID удобен для чтения человеком.</p>
	
	<p>Обычно все ProgID строятся по правилу: &lt;ИмяПрограммы&gt;.&lt;ИмяКласса&gt;.&lt;Версия&gt;, но многие разработчики отступают от этого правила и не указывают версию. Вот несколько примеров ProgID:</p>
	
	<p class="codebox"><span>Код</span> <span>Простой текст</span><br /><code>
		Visio.Application.3<br />
		Visio.Drawing.4<br />
		Word.Application.12<br />
		Microsoft.XmlHttp
	</code></p>
	
	<p>Уникальность ProgID не гарантируется, поэтому существует принципиальная опасность конфликта имен.</p>
	
	<h2><a id="">COM‐интерфейсы</a></h2>
	
	<p>COM накладывает дополнительные ограничения на интерфейсы:</p>
	
	<ul>
		<li>все COM‐интерфейсы прямо или косвенно наследуются от интерфейса <code>IUnknown</code>;</li>
		<li>за исключением методов <code>AddRef</code> и <code>Release</code>, все процедуры и функции должны возвращать тип данных <code>HRESULT</code>;</li>
		<li>«настоящее» возвращаемое значение заносится функцией в переданный ей указатель последним параметром.</li>
	</ul>
	
	<h3><a id="">Интерфейс IUnknown</a></h3>
	
	<p>Интерфейс <code>IUnknown</code> является краеугольным камнем технологии. Любой COM‐объект должен наследоваться либо интерфейса <code>IUnknown</code>, либо от производного от него.</p>
	
	<p>Интерфейс <code>IUnknown</code> концептуально играет две роли. Первая — это обеспечить стандартный способ получения интерфейса данного объекта. Эту возможность предоставляет метод <code>QueryInterface</code>. Вторая роль — это управление временем жизни объекта. Для этого предназначены два метода: <code>AddRef</code> и <code>Release</code>.</p>
	
	<p>Вот описание <code>IUnknown</code>:</p>
	
	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="keyword">Type</span> <span class="datatype">IUnknown</span> <span class="keyword">As</span> <span class="datatype">IUnknown_</span><br />
		<br />
		<span class="keyword">Type</span> <span class="datatype">IUnknownVirtualTable</span><br />
			<br />
			&t;<span class="keyword">Dim</span> QueryInterface <span class="keyword">As</span> <span class="datatype">Function</span>( _<br />
				&t;&t;<span class="keyword">ByVal</span> This <span class="keyword">As</span> <span class="datatype">IUnknown Ptr</span>, _<br />
				&t;&t;<span class="keyword">ByVal</span> riid <span class="keyword">As</span> <span class="datatype">REFIID</span>, _<br />
				&t;&t;<span class="keyword">ByVal</span> ppv <span class="keyword">As</span> <span class="datatype">Any Ptr Ptr</span> _<br />
			&t;)<span class="keyword">As</span> <span class="datatype">HRESULT</span><br />
			<br />
			&t;<span class="keyword">Dim</span> AddRef <span class="keyword">As</span> <span class="datatype">Function</span>( _<br />
				&t;&t;<span class="keyword">ByVal</span> This <span class="keyword">As</span> <span class="datatype">IUnknown Ptr</span> _<br />
			&t;)<span class="keyword">As</span> <span class="datatype">ULONG</span><br />
			<br />
			&t;<span class="keyword">Dim</span> Release <span class="keyword">As</span> <span class="datatype">Function</span>( _<br />
				&t;&t;<span class="keyword">ByVal</span> This <span class="keyword">As</span> <span class="datatype">IUnknown Ptr</span> _<br />
			&t;)<span class="keyword">As</span> <span class="datatype">ULONG</span><br />
			<br />
		<span class="keyword">End Type</span><br />
		<br />
		<span class="keyword">Type</span> <span class="datatype">IUnknown_</span><br />
			<br />
			&t;<span class="keyword">Dim</span> lpVtbl <span class="keyword">As</span> <span class="datatype">IUnknownVirtualTable Ptr</span><br />
			<br />
		<span class="keyword">End Type</span>
	</code></p>
	
	<p>Прежде чем пойти дальше, рассмотрим тип <code>HRESULT</code>, возвращаемый функцией <code>QueryInterface</code>.</p>
	
	<h3>Тип данных HRESULT</h3>
	
	<p>Исключая методы <code>AddRef</code> и <code>Release</code>, все методы COM‐интерфейсов обязаны возвращать тип данных <code>HRESULT</code>. Он представляет собой 32‐битное число, каждый бит которого зарезервирован для определённых целей. Название возникло по историческим причинам, просто расшифровывай его как «вот результат» (here is the result).</p>
	
	<dl>
	<dt>Бит 31</dt>
	<dd>Признак критичности: если установлен, то произошла непоправимая ошибка.</dd>
	</dl>
	
	<dl>
	<dt>Биты с 30 по 16</dt>
	<dd>Источник ошибки: какая часть операционной системы выдаёт данный код возврата.</dd>
	</dl>
	
	<dl>
	<dt>Биты с 15 по 0</dt>
	<dd>Собственно код возврата.</dd>
	</dl>
	
	<p>В таблице приведены часто используемые типы <code>HRESULT</code>. По соглашению в названиях успешных кодов содержится <code>S_</code>, а в названиях кодов ошибок <code>E_</code>.</p>
	
	<table>
		<tr>
			<th>Константа</th>
			<th>Описание</th>
			<th>Значение</th>
		</tr>
		<tr>
			<td>S_OK</td>
			<td>Функция отработала успешно. В некоторых случаях этот код также означает логическую истину.</td>
			<td>&amp;h00000000</td>
		</tr>
		<tr>
			<td>S_FALSE</td>
			<td>Функция отработала успешно и возвращает логическую ложь.</td>
			<td>&amp;h00000001</td>
		</tr>
		<tr>
			<td>E_FAIL</td>
			<td>Ошибка по неуказанной причине.</td>
			<td>&amp;h80004005</td>
		</tr>
		<tr>
			<td>E_ABORT</td>
			<td>Операция прервана.</td>
			<td>&amp;h80004004</td>
		</tr>
		<tr>
			<td>E_ACCESSDENIED</td>
			<td>Доступ запрещён.</td>
			<td>&amp;h80070005</td>
		</tr>
		<tr>
			<td>E_HANDLE</td>
			<td>Описатель недействителен.</td>
			<td>&amp;h80070006</td>
		</tr>
		<tr>
			<td>E_INVALIDARG</td>
			<td>Один или несколько аргументов неправильные.</td>
			<td>&amp;h80070057</td>
		</tr>
		<tr>
			<td>E_NOINTERFACE</td>
			<td>Запрашиваемый интерфейс не поддерживается.</td>
			<td>&amp;h80004002</td>
		</tr>
		<tr>
			<td>E_NOTIMPL</td>
			<td>Метод не реализован.</td>
			<td>&amp;h80004001</td>
		</tr>
		<tr>
			<td>E_OUTOFMEMORY</td>
			<td>Невозможно выделить память.</td>
			<td>&amp;h8007000E</td>
		</tr>
		<tr>
			<td>E_POINTER</td>
			<td>Указатель недействителен.</td>
			<td>&amp;h80004003</td>
		</tr>
		<tr>
			<td>E_UNEXPECTED</td>
			<td>Неожиданная ошибка.</td>
			<td>&amp;h8000FFFF</td>
		</tr>
	</table>
	
	<p>Большой и длинный список HRESULT можно найти <a href="https://msdn.microsoft.com/en-us/library/cc704587.aspx">в статье на MSDN «HRESULT Values»</a>.</p>
	
	<h4>Множественность кодов возврата</h4>
	
	<p>Для проверки успешного завершения нельзя сравнивать <code>HRESULT</code> с каким‐либо одним кодом, например, <code>S_OK</code> или <code>E_FAIL</code>, необходимо использовать предопределённые макросы <code>SUCCEEDED</code> и <code>FAILED</code>.</p>
	
	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="keyword">Dim</span> hr <span class="keyword">As</span> <span class="datatype">HRESULT</span><br />
		<br />
		<span class="remark">&apos; Не делай так:</span><br />
		<span class="keyword">If</span> hr = E_FAIL <span class="keyword">Then</span><br />
			&t;<span class="keyword">Print</span> <span class="string">&quot;Ошибка&quot;</span><br />
		<span class="keyword">End If</span><br />
		<span class="keyword">If</span> hr = S_OK <span class="keyword">Then</span><br />
			&t;<span class="keyword">Print</span> <span class="string">&quot;Успешно&quot;</span><br />
		<span class="keyword">End If</span><br />
		<br />
		<span class="remark">&apos; Следует делать так:</span><br />
		<span class="keyword">If</span> FAILED(hr) <span class="keyword">Then</span><br />
			&t;<span class="keyword">Print</span> <span class="string">&quot;Ошибка&quot;</span><br />
		<span class="keyword">End If</span><br />
		<span class="keyword">If</span> SUCCEEDED(hr) <span class="keyword">Then</span><br />
			&t;<span class="keyword">Print</span> <span class="string">&quot;Успешно&quot;</span><br />
		<span class="keyword">End If</span>
	</code></p>
	
	<h3>Метод QueryInterface</h3>
	
	<p>Метод <code>QueryInterface</code> предназначен для получения интерфейса по его идентификатору <code>IID</code> у интерфейса. <code>IID</code> передаётся как указатель вторым параметром (для высокоуровневых языков — первым, в них контекст вызова скрыт от программиста). Если интерфейс реализует и поддерживает конкретный интерфейс, то в третий параметр метод записывает указатель на него. Как минимум, у интерфейса можно запросить указатели на <code>IUnknown</code> и самого себя, потому что любой интерфейс наследуется от <code>IUnknown</code> и реализует самого себя.</p>
	
	<p>Для упрощения понимания функцию <code>QueryInterface</code> можно считать как метод создания объекта, реализующего определённый интерфейс.</p>
	
	<p>Функция <code>QueryInterface</code> может возвратить либо <code>S_OK</code>, либо <code>E_NOINTERFACE</code>, тем не менее, клиент не должен прямо сравнивать возвращаемое значение функции с этими константами; для проверки следует использовать макросы <code>SUCCEEDED</code> или <code>FAILED</code>.</p>
	
	<h3>Методы AddRef и Release</h3>
	
	<p>За управление временем жизни компонентов отвечают два метода интерфейса <code>IUnknown</code>: <code>AddRef</code> и <code>Release</code> через подсчёт ссылок на объект. Всякий раз, когда клиент запрашивает интерфейс, значение счётчика ссылок будет увеличиваться, а когда клиент завершает работу с интерфейсом — уменьшаться. В конце концов, когда значение счётчика ссылок станет равным нулю, объект будет самоуничтожен. Именно для этого и служат методы <code>AddRef</code> и <code>Release</code>.</p>
	
	<p>Пользователь компонента не может непосредственно удалить экземпляр объекта, поскольку в его распоряжении имеется только указатель на виртуальную таблицу функций. В действительности клиент не имеет права удалять объект в любом случае, поскольку могут существовать другие клиенты, использующие тот же объект. Только сам объект, основываясь на значении своего внутреннего счетчика обращений, может определить момент своего уничтожения.</p>
	
	
	
	<!--
	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="keyword">Type</span> <span class="datatype">IMath</span><br />
	</code></p>
	-->
	
	<h2>Поделись ссылочкой в социальных сетях</h2>
	<div id="vk_share_button"></div>
	
</main>

<hr />

<footer>
	<p>«Пакетные файлы» создали этот сайт по технологии XHTML 11 марта 2016 года</p>
	<p id="pLiveInternet"></p>
</footer>

<script type="text/javascript" src="https://vk.com/js/api/share.js?93" charset="windows-1251"></script>
<script type="text/javascript">var docUrl=document.URL.toString();document.getElementById("vk_share_button").innerHTML=VK.Share.button(docUrl, {type: "round"});</script>

<script type="text/javascript">var idL=document.getElementById("pLiveInternet");var idA=document.createElement("a");idA.href="//www.liveinternet.ru/stat/freebasic.su";idA.title="Логотип LiveInternet";var idImg=document.createElement("img");idImg.src="//counter.yadro.ru/hit?t44."+Math.round(1+18*Math.random())+";r"+escape(document.referrer)+((typeof(screen)=="undefined")?"":";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+";"+Math.random();idImg.alt="Счётчик посещений LiveInternet";idA.appendChild(idImg);idL.appendChild(idA);</script>

</body></html>