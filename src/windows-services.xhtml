<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"[

	<!ENTITY nbsp "&#160;">
	<!ENTITY t "&#160;&#160;&#160;&#160;">
	
]>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

<head>
	<title>Службы Windows (Windows Service)</title>
	<meta name="description" content="Описание статьи" />
	<meta name="keywords" content="служба Windows, Windows Service, FreeBASIC, WinAPI" />
	
	<link href="/styles.css" type="text/css" rel="stylesheet" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	
</head>

<body>

<header>
	
	<nav>
		<p><a href="/">Главная</a></p>
		<p><a href="/src/">Статьи</a></p>
		<p><a href="/code/">Проекты</a></p>
		<p><a href="/books/">Учебник</a></p>
		<p><a href="/links.xhtml">Ссылки</a></p>
		<p><a href="/about.xhtml">О сайте</a></p>
	</nav>
	
</header>

<h1>Службы Windows (Windows Service)</h1>

<main>

	<p class="postername">
		<a href="/users/mabu.xhtml">
			<img src="/avatars/mabu.jpg" alt="Аватар пользователя" width="50" height="50" class="avatar" />
			&#32;
			mabu
		</a>
		&#32;
		<time pubdate="pubdate">2016-03-05T23:25:31+07:00</time>
	</p>


	<p>Как правило, служба Windows — это приложение, предназначенное для работы без взаимодействия с пользователем. Службы выполняются в отдельной оконной станции, поэтому пользовательский ввод с клавиатуры, мыши или консоли им недоступен.</p>

	<p>Все службы запускаются диспетчером управления служб — программой <code>services.exe</code>. Службы могут быть однопоточными — по одной службе на один исполняемый файл, и многопоточными — больше одной службы на один исполняемый файл, каждая выполняется в своём потоке.</p>


	<ol class="contents">
		<li><a href="#c1">Функции</a>
			<ol>
				<li><a href="#c1c1">StartServiceCtrlDispatcher</a></li>
				<li><a href="#c1c3">RegisterServiceCtrlHandler</a></li>
				<li><a href="#c1c5">SetServiceStatus</a></li>
			</ol>
		</li>
		<li><a href="#c2">Пример</a></li>
	</ol>


	<h2><a id="c1">Функции</a></h2>

	<p>Не любая программа может быть запущена как служба. Чтобы диспетчер мог запустить программу как службу, программа должна взаимодействовать с диспетчером. Нам понадобятся всего три функции непосредственно для создания службы:</p>

	<ul>
		<li><code>StartServiceCtrlDispatcher</code> — сообщает диспетчеру о готовности запуска службы;</li>
		<li><code>RegisterServiceCtrlHandler</code> — регистрирует функцию‐обработчик сообщений от диспетчера;</li>
		<li><code>SetServiceStatus</code> — сообщает диспетчеру состояние службы.</li>
	</ul>

	<p>И вспомогательные функции для работы службы:</p>

	<ul>
		<li><code>CreateEvent</code> — создаёт событие синхронизации потоков;</li>
		<li><code>WaitForSingleObject</code> — ожидает событие;</li>
		<li><code>SetEvent</code> — устанавливает событие.</li>
	</ul>


	<h3><a id="c1c1">StartServiceCtrlDispatcher</a></h3>

	<p>Сообщает диспетчеру служб о готовности работать в качестве службы. Эта функция должна быть вызвана как можно скорее после запуска программы, иначе диспетчер сочтёт, что служба зависла и завершит её.</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Declare</span> <span class="keyword">Function</span> StartServiceCtrlDispatcher <span class="keyword">Alias</span> <span class="string">&quot;StartServiceCtrlDispatcherW&quot;</span>( _<br />
	&t;<span class="keyword">ByVal</span> lpServiceStartTable <span class="keyword">As</span> <span class="datatype">Const SERVICE_TABLE_ENTRYW Ptr</span>) _<br />
	<span class="keyword">As</span> <span class="datatype">WINBOOL</span>
	</code></p>


	<h4>Параметры</h4>

	<dl>
	<dt>lpServiceStartTable</dt>
	<dd>Указатель на массив структур <code>SERVICE_TABLE_ENTRY</code>, содержащих данные об именах служб и точек входа.</dd>
	</dl>


	<h4>Возвращаемое значение</h4>

	<p>Если диспетчер принял данные о запуске служб, то возвращаемое значение — не ноль.</p>

	<p>Если произошла ошибка, то возвращаемое значение — ноль. Для дополнительных сведений об ошибке можно вызвать функцию <code>GetLastError</code>.</p>

	<p>Вот типичные коды ошибок:</p>

	<ul>
		<li><code>ERROR_FAILED_SERVICE_CONTROLLER_CONNECT</code> — запуск службы из консоли, а не из диспетчера;</li>
		<li><code>ERROR_INVALID_DATA</code> — неправильные данные в реестре или при вызове функции <code>StartServiceCtrlDispatcher</code>;</li>
		<li><code>ERROR_SERVICE_ALREADY_RUNNING</code> — служба уже запущена.</li>
	</ul>


	<h4>Замечания</h4>

	<p>После вызова функции <code>StartServiceCtrlDispatcher</code> диспетчер возвратит управление только тогда, когда все службы, указанные в массиве <code>SERVICE_TABLE_ENTRY</code> будут остановлены, или в случае ошибки.</p>


	<h3>Структура SERVICE_TABLE_ENTRY</h3>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Type</span> <span class="datatype">SERVICE_TABLE_ENTRY</span><br />
	&t;lpServiceName <span class="keyword">As</span> <span class="datatype">LPWSTR</span><br />
	&t;lpServiceProc <span class="keyword">As</span> <span class="datatype">LPSERVICE_MAIN_FUNCTIONW</span><br />
	<span class="keyword">End Type</span>
	</code></p>


	<h4>Члены структуры</h4>

	<dl>
	<dt>lpServiceName</dt>
	<dd>Указатель на строку с именем службы.</dd>
	</dl>

	<dl>
	<dt>lpServiceProc</dt>
	<dd>Указатель на функцию, которую вызовет диспетчер как точку входа в службу.</dd>
	</dl>


	<h3><a id="c1c2">Точка входа в службу</a></h3>

	<p>Точка входа в службу — это обычная процедура, которая должна иметь следующий вид:</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Declare</span> <span class="keyword">Sub</span> SvcMain( _<br/>
	&t;<span class="keyword">ByVal</span> dwNumServicesArgs <span class="keyword">As</span> <span class="datatype">DWORD</span>, _<br/>
	&t;<span class="keyword">ByVal</span> lpServiceArgVectors <span class="keyword">As</span> <span class="datatype">LPWSTR Ptr</span>)
	</code></p>


	<h4>Параметры</h4>

	<dl>
	<dt>dwNumServicesArgs</dt>
	<dd>Количество параметров командной строки + имя службы.</dd>
	</dl>

	<dl>
	<dt>lpServiceArgVectors</dt>
	<dd>Массив указателей на строки. Это параметры командной строки, первым параметром будет идти имя службы.</dd>
	</dl>


	<h4>Возвращаемое значение</h4>

	<p>Функция не возвращает значений.</p>


	<h4>Замечания</h4>

	<p>На самом деле имя функции может быть любым, главное, чтобы параметры соответствовали объявлению.</p>


	<h3><a id="c1c3">RegisterServiceCtrlHandler</a></h3>

	<p>Регистрирует функцию‐обработчик команд для управления службой. Диспетчер будет вызывать эту функцию всякий раз, чтобы отправить ей специальный код.</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Declare</span> <span class="keyword">Function</span> RegisterServiceCtrlHandler <span class="keyword">Alias</span> <span class="string">&quot;RegisterServiceCtrlHandlerW&quot;</span>( _<br />
	&t;<span class="keyword">ByVal</span> lpServiceName <span class="keyword">As</span> <span class="datatype">LPCWSTR</span>, _<br />
	&t;<span class="keyword">ByVal</span> lpHandlerProc <span class="keyword">As</span> <span class="datatype">LPHANDLER_FUNCTION</span>) _<br />
	<span class="keyword">As</span> <span class="datatype">SERVICE_STATUS_HANDLE</span>
	</code></p>


	<h4>Параметры</h4>

	<dl>
	<dt>lpServiceName</dt>
	<dd>Указатель на строку с именем службы.</dd>
	</dl>

	<dl>
	<dt>lpHandlerProc</dt>
	<dd>Указатель на функцию, которую вызовет диспетчер когда службе будет отправлен сигнал.</dd>
	</dl>


	<h4>Возвращаемое значение</h4>

	<p>Если функция выполнилась успешно, то возвращаемое значение идентификатор службы.</p>

	<p>Если функция выдала ошибку, то возвращаемое значение — ноль. Для дополнительной информации об ошибке можно вызвать функцию <code>GetLastError</code></p>

	<p>Вот типичные коды ошибок:</p>

	<ul>
		<li><code>ERROR_NOT_ENOUGH_MEMORY</code> — недостаточно памяти для конвертации имени службы из однобитной кодировки в юникод, эта ошибка не появляется при вызове юникодной версии функции;</li>
		<li><code>ERROR_SERVICE_NOT_IN_EXE</code> — служба запускается не из исполняемого файла.</li>
	</ul>


	<h4>Замечания</h4>

	<p>Эта функция должна быть вызвана как можно скорее после вызова <code>StartServiceCtrlDispatcher</code>, чтобы диспетчер смог зарегистрировать обработчик сигналов управления службой. Иначе диспетчер сочтёт, что служба зависла и завершит её.</p>

	<p>Идентификатор, возвращаемый функцией <code>RegisterServiceCtrlHandler</code> не следует закрывать.</p>


	<h3><a id="c1c4">Функция‐обработчик команд диспетчера</a></h3>

	<p>Обработчик команд диспетчера должен иметь следующий вид:</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Declare</span> <span class="keyword">Sub</span> SvcCtrlHandler( _<br />
	&t;<span class="keyword">ByVal</span> dwCtrl <span class="keyword">As</span> <span class="datatype">DWORD</span>)
	</code></p>

	<h4>Параметры</h4>

	<dl>
	<dt>dwCtrl</dt>
	<dd>Специальное число, отправляемое диспетчером. Это число может быть одной из следующих констант:

	<ul>
		<li><code>SERVICE_CONTROL_INTERROGATE</code> — диспетчер требует у службы текущее состояние, необходимо отправить диспетчеру <code>NO_ERROR</code> функцией <code>SetServiceStatus</code>;</li>
		<li><code>SERVICE_CONTROL_CONTINUE</code> — диспетчер запускает службу или снимает с паузы;</li>
		<li><code>SERVICE_CONTROL_PAUSE</code> — диспетчер ставит службу на паузу;</li>
		<li><code>SERVICE_CONTROL_STOP</code> — диспетчер останавливает службу, необходимо завершить работу службы, тем не менее, это не значит, что диспетчер выгрузит службу из памяти;</li>
		<li><code>SERVICE_CONTROL_SHUTDOWN</code> — операционная система завершает работу, служба должна отправить <code>NO_ERROR</code> функцией <code>SetServiceStatus</code>.</li>
	</ul>

	Также диспетчер может отправлять пользовательские коды из диапазона от 128 до 255, что с ними делать — это усматривает сам разработчик.
	</dd>
	</dl>


	<h4>Возвращаемое значение</h4>

	<p>Функция не возвращает значений.</p>


	<h4>Замечания</h4>

	<p>Любая служба обязана уметь обрабатывать код <code>SERVICE_CONTROL_INTERROGATE</code>.</p>

	<p>Диспетчер не гарантирует отправление кодов по очереди. Служба должна обрабатывать ситуации, когда коды будут поступать вразнобой или дублироваться. Например, может дважды прийти код паузы, может прийти код возобновления работы в то время как служба уже работает.</p>

	<p>Функция должна обрабатывать коды как можно быстрее, иначе диспетчер сочтёт службу зависшей и уничтожит.</p>


	<h3><a id="c1c5">SetServiceStatus</a></h3>

	<p>Сообщает диспетчеру состояние службы.</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Declare</span> <span class="keyword">Function</span> SetServiceStatus( _<br />
	&t;<span class="keyword">ByVal</span> hServiceStatus <span class="keyword">As</span> <span class="datatype">SERVICE_STATUS_HANDLE</span>, _<br />
	&t;<span class="keyword">ByVal</span> lpServiceStatus <span class="keyword">As</span> <span class="datatype">LPSERVICE_STATUS</span>) _<br />
	<span class="keyword">As</span> <span class="datatype">WINBOOL</span>
	</code></p>


	<h4>Параметры</h4>

	<dl>
	<dt>hServiceStatus</dt>
	<dd>Идентификатор службы, возвращённый функцией <code>RegisterServiceCtrlHandler</code>.</dd>
	</dl>

	<dl>
	<dt>lpServiceStatus</dt>
	<dd>Указатель на структуру <code>SERVICE_STATUS</code>.</dd>
	</dl>


	<h4>Возвращаемое значение</h4>

	<p>Если функция выполняется успешно, то возвращаемое значение — не ноль.</p>

	<p>Если функция завершается ошибкой, то возвращаемое значение — ноль.</p>


	<h4>Замечания</h4>

	<p>После вызова функции <code>RegisterServiceCtrlHandler</code> необходимо как можно скорее сообщить диспетчеру состояние службы, вызвав функцию <code>SetServiceStatus</code> с кодом <code>SERVICE_START_PENDING</code>. Иначе диспетчер сочтёт службу зависшей и уничтожит.</p>

	<p>Также о любом изменении состояния службы (запущена, остановлена, поставлена на паузу) необходимо извещать диспетчер.</p>


	<h3>Структура SERVICE_STATUS</h3>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="keyword">Type</span> <span class="datatype">SERVICE_STATUS</span><br />
	&t;dwServiceType <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwCurrentState <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwControlsAccepted <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwWin32ExitCode <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwServiceSpecificExitCode <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwCheckPoint <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	&t;dwWaitHint <span class="keyword">As</span> <span class="datatype">DWORD</span><br />
	<span class="keyword">End Type</span>
	</code></p>


	<h4>Члены структуры:</h4>

	<dl>
	<dt>dwServiceType</dt>
	<dd>Тип службы. Нас интересуют значения <code>SERVICE_WIN32_OWN_PROCESS</code> для однопоточной службы и <code>SERVICE_WIN32_SHARE_PROCESS</code> для многопоточных служб.</dd>
	</dl>

	<dl>
	<dt>dwCurrentState</dt>
	<dd>Текущее состояние службы. Необходимо устанавливать, чтобы сообщить диспетчеру, что сейчас делает служба:
	<ul>
		<li><code>SERVICE_START_PENDING</code> — служба готовится к запуску;</li>
		<li><code>SERVICE_RUNNING</code> — служба запущена и работает;</li>
		<li><code>SERVICE_PAUSE_PENDING</code> — служба ставится на паузу;</li>
		<li><code>SERVICE_PAUSED</code> — служба поставлена на паузу;</li>
		<li><code>SERVICE_CONTINUE_PENDING</code> — служба продолжает работу;</li>
		<li><code>SERVICE_STOP_PENDING</code> — служба готовится к остановке;</li>
		<li><code>SERVICE_STOPPED</code> — служба остановлена.</li>
	</ul>
	</dd>
	</dl>

	<dl>
	<dt>dwControlsAccepted</dt>
	<dd>Указывает диспетчеру, какие команды управления может принимать служба.

	<ul>
		<li><code>SERVICE_ACCEPT_PAUSE_CONTINUE</code> — служба обрабатывает сообщения о паузе и возобновлении;</li>
		<li><code>SERVICE_ACCEPT_SHUTDOWN</code> — служба обрабатывает сообщения о завершении системы;</li>
		<li><code>SERVICE_ACCEPT_STOP</code> — служба обрабатывает сообщения об останове.</li>
	</ul>

	В простом случае достаточно указать <code>SERVICE_ACCEPT_STOP</code>, чтобы диспетер отправлял сигналы остановки и запуска. Тем не менее, диспетчер в любом случае также будет отправлять код <code>SERVICE_CONTROL_INTERROGATE</code>.</dd>
	</dl>

	<dl>
	<dt>dwWin32ExitCode</dt>
	<dd>Код завершения программы. Если не было ошибок, необходимо устанавливать в <code>NO_ERROR</code>.</dd>
	</dl>

	<dl>
	<dt>dwServiceSpecificExitCode</dt>
	<dd>Код завершения службы. Если не было ошибок, необходимо устанавливать в <code>NO_ERROR</code>.</dd>
	</dl>

	<dl>
	<dt>dwCheckPoint</dt>
	<dd>Это значение служба должна периодически увеличивать, чтобы сообщать диспетчеру о прогрессе длительных операций запуска, остановки и прочего.</dd>
	</dl>

	<dl>
	<dt>dwWaitHint</dt>
	<dd>Максимальное значение, до которого служба будет увеличивать <code>dwCheckPoint</code>. Диспетчер будет использовать для построения прогресса длительных операций.</dd>
	</dl>


	<h2><a id="c2">Пример</a></h2>

	<p>Создадим простую службу с именем <code>MyNewService</code>, которая не будет ничего делать. Этот код можно использовать как заготовку для служб.</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	#define unicode<br />
	#include once &quot;windows.bi&quot;<br />
	<br />
	Declare Sub ReportSvcStatus(ByVal dwCurrentState As DWORD, ByVal dwWin32ExitCode As DWORD, ByVal dwWaitHint As DWORD)<br />
	Declare Sub SvcMain(ByVal dwNumServicesArgs As DWORD, ByVal lpServiceArgVectors As LPWSTR Ptr)<br />
	Declare Sub SvcCtrlHandler(ByVal dwCtrl As DWORD)<br />
	<br />
	&apos; Имя службы<br />
	Const ServiceName = &quot;MyNewService&quot;<br />
	<br />
	&apos; Состояние службы<br />
	Dim Shared gSvcStatus As SERVICE_STATUS<br />
	&apos; идентификатор службы<br />
	Dim Shared gSvcStatusHandle As SERVICE_STATUS_HANDLE<br />
	&apos; Событие<br />
	Dim Shared ghSvcStopEvent As HANDLE<br />
	&apos; Счётчик длительных операций<br />
	Dim Shared dwCheckPoint As DWORD<br />
	<br />
	<br />
	&apos; TODO Добавить любые дополнительные службы в этот список<br />
	Dim DispatchTable(1) As SERVICE_TABLE_ENTRY = Any<br />
	DispatchTable(0).lpServiceName = @ServiceName<br />
	DispatchTable(0).lpServiceProc = @SvcMain<br />
	&apos; Массив должен заканчиваться пустым элементом<br />
	DispatchTable(1).lpServiceName = 0<br />
	DispatchTable(1).lpServiceProc = 0<br />
	<br />
	&apos; Вызов функции StartServiceCtrlDispatcher возвращает значение когда служба завершится<br />
	If StartServiceCtrlDispatcher(@DispatchTable(0)) = 0 Then<br />
	&t;&apos; Произошла ошибка<br />
	&t;Select Case GetLastError()<br />
	&t;&t;Case ERROR_FAILED_SERVICE_CONTROLLER_CONNECT<br />
	&t;&t;&t;Print &quot;Запуск из консоли&quot;<br />
	&t;&t;Case ERROR_INVALID_DATA<br />
	&t;&t;&t;Print &quot;Неправильные данные&quot;<br />
	&t;&t;Case ERROR_SERVICE_ALREADY_RUNNING<br />
	&t;&t;&t;Print &quot;Служба уже запущена&quot;<br />
	&t;End Select<br />
	End If<br />
	&apos; Процесс должен завершаться как можно проще:<br />
	ExitProcess(0)<br />
	<br />
	&apos; Точка входа службы<br />
	&apos; Параметры:<br />
	&apos; dwArgc — количество аргументов командной строки<br />
	&apos; lpszArgv — массив аргументов командной строки<br />
	Sub SvcMain(ByVal dwNumServicesArgs As DWORD, ByVal lpServiceArgVectors As LPWSTR Ptr)<br />
	&t;&apos; Регистрация функции‐обработчика сообщений от контроллёра<br />
	&t;gSvcStatusHandle = RegisterServiceCtrlHandler(@ServiceName, @SvcCtrlHandler)<br />
	&t;If gSvcStatusHandle = 0 Then<br />
	&t;&t;&apos; Какая‐то ошибка<br />
	&t;&t;Exit Sub<br />
	&t;End If<br />
	&t;<br />
	&t;&apos; Заполнить структуру SERVICE_STATUS<br />
	&t;gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS<br />
	&t;gSvcStatus.dwServiceSpecificExitCode = 0<br />
	&t;<br />
	&t;&apos; Сообщить контроллёру, что служба ожидает<br />
	&t;ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000)<br />
	&t;<br />
	&t;&apos; TODO Добавить необходимых инициализаций<br />
	&t;&apos; Необходимо периодически сообщать контроллёру SERVICE_START_PENDING<br />
	&t;&apos; чтобы контроллёр не считал службу зависшей<br />
	&t;&apos; Если инициализация не удалась необходимо<br />
	&t;&apos; сообщить контроллёру SERVICE_STOPPED<br />
	&t;<br />
	&t;&apos; Событие, которое будем ожидать для завершения службы<br />
	&t;ghSvcStopEvent = CreateEvent(NULL, _ /&apos; атрибуты безопасности по умолчанию &apos;/<br />
	&t;&t;TRUE, _ /&apos; ручное сбрасывание &apos;/<br />
	&t;&t;FALSE, _ /&apos; событие ещё не произошло &apos;/<br />
	&t;&t;NULL) /&apos; без имени &apos;/<br />
	&t;<br />
	&t;&apos; Если событие не создано, то сообщить контроллёру,<br />
	&t;&apos; что служба остановлена и выйти<br />
	&t;If ghSvcStopEvent = NULL Then<br />
	&t;&t;ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0)<br />
	&t;&t;Exit Sub<br />
	&t;End If<br />
	&t;<br />
	&t;&apos; Сообщить контроллёру, что служба запущена<br />
	&t;ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0)<br />
	&t;<br />
	&t;&apos; TODO Делать полезную работу службы<br />
	&t;&apos; Например, запустить поток, в котором будет идти основная работа<br />
	&t;<br />
	&t;&apos; Ожидать до тех пор, пока служба не остновится<br />
	&t;WaitForSingleObject(ghSvcStopEvent, INFINITE)<br />
	&t;ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0)<br />
	End Sub<br />
	<br />
	&apos; Вызывается контроллёром и отправляет управляющий код службе<br />
	&apos; Параметры:<br />
	&apos; dwCtrl — управляющий код<br />
	Sub SvcCtrlHandler(ByVal dwCtrl As DWORD)<br />
	&t;&apos; Эти коды могут поступать в любом порядке,<br />
	&t;&apos; даже если предыдущие операции не завершены<br />
	&t;Select Case dwCtrl<br />
	&t;&t;Case SERVICE_CONTROL_INTERROGATE<br />
	&t;&t;&t;ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0)<br />
	&t;&t;Case SERVICE_CONTROL_STOP<br />
	&t;&t;&t;&apos; Код остановки службы<br />
	&t;&t;&t;ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0)<br />
	&t;&t;&t;&apos; Установить событие для остановки службы<br />
	&t;&t;&t;SetEvent(ghSvcStopEvent)<br />
	&t;&t;Case Else<br />
	&t;&t;&t;&apos; Обработка собственных кодов<br />
	&t;End Select<br />
	End Sub<br />
	<br />
	&apos; Сообщение котроллёру состояния службы<br />
	&apos; Параметры:<br />
	&apos; dwCurrentState — текущее состояние службы<br />
	&apos; dwWin32ExitCode — код ошибки<br />
	&apos; dwWaitHint — расчётное время операции, в миллисекундах<br />
	Sub ReportSvcStatus(ByVal dwCurrentState As DWORD, ByVal dwWin32ExitCode As DWORD, ByVal dwWaitHint As DWORD)<br />
	&t;&apos; Заполнить структуру SERVICE_STATUS<br />
	&t;gSvcStatus.dwCurrentState = dwCurrentState<br />
	&t;gSvcStatus.dwWin32ExitCode = dwWin32ExitCode<br />
	&t;gSvcStatus.dwWaitHint = dwWaitHint<br />
	&t;<br />
	&t;If dwCurrentState = SERVICE_START_PENDING Then<br />
	&t;&t;gSvcStatus.dwControlsAccepted = 0<br />
	&t;Else<br />
	&t;&t;gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP<br />
	&t;End If<br />
	&t;<br />
	&t;If dwCurrentState = SERVICE_RUNNING Or dwCurrentState = SERVICE_STOPPED Then<br />
	&t;&t;gSvcStatus.dwCheckPoint = 0<br />
	&t;Else<br />
	&t;&t;dwCheckPoint += 1<br />
	&t;&t;gSvcStatus.dwCheckPoint = dwCheckPoint<br />
	&t;End If<br />
	&t;<br />
	&t;&apos; Сообщить состояние службы контроллёру<br />
	&t;SetServiceStatus(gSvcStatusHandle, @gSvcStatus)<br />
	End Sub
	</code></p>

	<p>Для компиляции необходимо использовать многопоточную библиотеку времени выполнения, то есть компилировать с параметром <code>-mt</code>.</p>

	<h3>Регистрация и запуск службы</h3>

	<p>Для регистрации службы в базе данных диспетчера можно воспользоваться утилитой <code>sc</code>:</p>

	<p class="codebox"><span>Код</span> <span>Batch</span><br /><code>
	set current_dir=%~dp0<br />
	sc create MyNewService binPath= &quot;%current_dir%MyNewService.exe&quot; start= &quot;auto&quot;
	</code></p>

	<p>Теперь, если открыть остастку управления службами <code>services.msc</code>, то можно увидеть нашу службу в списке служб.</p>

	<p>Запустить службу можно прямо из оснастки управления или этой командой:</p>

	<p class="codebox"><span>Код</span> <span>Batch</span><br /><code>
	sc start MyNewService
	</code></p>


	<h2>Поделись ссылочкой в социальных сетях</h2>
	<div id="vk_share_button"></div>

</main>

<hr />

<footer>
	<p>Сайт создан по технологии XHTML</p>
	<p>
		<span id="pLiveInternet"></span>
		<a href="http://wscatalog.ru/dir/programmirovanie-na-yazyke-freebasic" title="Сайт есть в Каталоге">
			<img width="88" height="31" src="http://wscatalog.ru/knopka.png" alt="Логотип wscatalog.ru" />
		</a>
		<a href="http://gluci.ru/dir/freebasic-na-russkom" title="Необычный Каталог Сайтов">
			<img width="88" height="31" src="http://gluci.ru/88x31.png" alt="Логотип Глюки" />
		</a> 
	</p>
</footer>

<script type="text/javascript" src="https://vk.com/js/api/share.js?93" charset="windows-1251"></script>
<script type="text/javascript">var docUrl=document.URL.toString();document.getElementById("vk_share_button").innerHTML=VK.Share.button(docUrl, {type: "round"});</script>


<script type="text/javascript">var idL=document.getElementById("pLiveInternet");var idA=document.createElement("a");idA.href="//www.liveinternet.ru/stat/freebasic.su";idA.title="Счётчик посещений LiveInternet";var idImg=document.createElement("img");idImg.src="//counter.yadro.ru/hit?t44."+Math.round(1+18*Math.random())+";r"+escape(document.referrer)+((typeof(screen)=="undefined")?"":";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?screen.colorDepth:screen.pixelDepth))+";u"+escape(docUrl)+";"+Math.random();idImg.alt="Логотип LiveInternet";idA.appendChild(idImg);idL.appendChild(idA);</script>

</body></html>