<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"[

	<!ENTITY nbsp "&#160;">
	<!ENTITY t "&#160;&#160;&#160;&#160;">
	
]>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

<head>
	<title>Кодирование base64</title>
	<meta name="description" content="Кодирование и декодирование данных в base64" />
	<meta name="keywords" content="base64, кодирование, декодирование, FreeBASIC, unicode, WinAPI" />
	
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link href="/styles.css" type="text/css" rel="stylesheet" />
	<style type="text/css">span.memorygroup{padding:0.25em;}span.memorydata{font-family:monospace,monospace;color:#000000;border:solid 2px #CCCCCC;padding:0.25em;}</style>
</head>

<body>

<header>
	
	<nav>
		<p><a href="/">Главная</a></p>
		<p><a href="/articles/">Статьи</a></p>
		<p><a href="/projects/">Проекты</a></p>
		<p><a href="/books/">Учебник</a></p>
		<p><a href="/links.xhtml">Ссылки</a></p>
		<p><a href="/about.xhtml">О сайте</a></p>
	</nav>
	
</header>


<h1>Кодирование base64</h1>

<main>
	<p class="postername">
		<a href="/users/mabu.xhtml">
			<img src="/avatars/mabu.jpg" alt="Аватар пользователя" width="50" height="50" class="avatar" />
			&#32;
			mabu
		</a>
		&#32;
		<time pubdate="pubdate">2016-05-22T00:46:54+07:00</time>
	</p>

	<p><strong>Base64</strong> буквально означает — позиционная система счисления с основанием 64. Здесь 64 — это число символов в алфавите кодирования, из которого формируется конечный буквенно‐цифровой текст на основе латинского алфавита. Число соответствует наибольшей степени двойки (2^6), которая может быть представлена с использованием печатных символов ASCII.</p>

	<ol class="contents">
		<li><a href="#c1">Зачем это нужно?</a></li>
		<li><a href="#c2">Алгоритм</a></li>
		<li><a href="#c3">Где же код?</a></li>
		<li><a href="#c4">Использование</a></li>
	</ol>


	<h2><a id="c1">Зачем это нужно?</a></h2>

	<p>Так исторически сложилось, что многие форматы передачи и хранения данных (html, url схемы, xml, email и тому подобное) используют текст вместо бинарных кодов. Но если формат передачи данных текстовый, а передать необходимо бинарные данные (отдельно либо вместе с текстовыми данными) — тут на помощь приходит base64. Например:</p>
	<ul>
		<li>data: URL схемы для изображений в CSS, HTML;</li>
		<li>передача картинок и других данных внутри XML, не используя внешние файлы;</li>
		<li>хранение изображений в базах данных;</li>
		<li>вложения в электронной почте;</li>
		<li>сертификаты, шифрование и электронные подписи.</li>
	</ul>

	<p>И это не исчепывающий список, где применяется base64.</p>


	<h2><a id="c2">Алгоритм</a></h2>

	<p>Алгоритм кодирования прост. Берётся тройка октетов. 3 откета по 8 бит — это 24 бита. С другой стороны 24 бита — это 4 раза по 6 бит. Получившиеся четыре шестибитных числа представляют индексы символов в следующей строке:</p>
	<p class="codebox"><span></span> <span></span><br /><code>
	ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
	</code></p>

	<p>Для примера закодируем строку «Man» в base64.</p>

	<p>Исходные данные: строка «Man»</p>
	<p>Коды символов: 
		<span class="memorygroup">
			<span class="memorydata">77</span>
			<span class="memorydata">97</span>
			<span class="memorydata">110</span>
		</span>
	</p>
	<p>Двоичный вид с группировкой по 8 бит: 
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
		</span>
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
		</span>
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
		</span>
	</p>
	<p>Двоичный вид с группировкой по 6 бит: 
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
		</span>
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
		</span>
		<span class="memorygroup">
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
		</span>
		<span class="memorygroup">
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">1</span>
			<span class="memorydata">0</span>
		</span>
	</p>
	<p>Полученные индексы в base64: 
		<span class="memorygroup">
			<span class="memorydata">19</span>
			<span class="memorydata">22</span>
			<span class="memorydata">5</span>
			<span class="memorydata">46</span>
		</span>
	</p>

	<p>Конечный результат в Base64: 
		<span class="memorygroup">
			<span class="memorydata">T</span>
			<span class="memorydata">W</span>
			<span class="memorydata">F</span>
			<span class="memorydata">u</span>
		</span>
	</p>

	<p>Если длина результирующей строки не кратна четырём, то её дополняют необходимым количеством символов «=».</p>


	<h2><a id="c3">Где же код?</a></h2>

	<p>Довольно теоретизирований, перейдём к коду.</p>

	<p>Заголовочный файл base64.bi:</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="remark">&apos; Кодирование в Base64 и обратно</span><br />
		<span class="preprocessor">#ifndef unicode</span><br />
		&t;<span class="preprocessor">#define unicode</span><br />
		<span class="preprocessor">#endif</span><br />
		<span class="preprocessor">#include once &quot;windows.bi&quot;</span><br />
		<span class="preprocessor">#include once &quot;win\shlwapi.bi&quot;</span><br />
		<br />
		<span class="keyword">Const</span> B64 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br />
		<span class="keyword">Const</span> Base64StringLength <span class="keyword">As</span> <span class="keyword">Integer</span> = 19<br />
		<br />
		<span class="remark">&apos; Шифрует массив байт в base64</span><br />
		<span class="remark">&apos; sOut — указатель на буфер под результирующую строку</span><br />
		<span class="remark">&apos; sEncodedB — указатель на массив байт, которые нужно закодировать</span><br />
		<span class="remark">&apos; BytesCount — количество байт в массиве</span><br />
		<span class="remark">&apos; Функция может записать за выделенный буфер, если он будет слишком мал</span><br />
		<span class="remark">&apos; Размер требуемого буфера под результирующую строку должен быть не менее ((BytesCount \ 3) + 1) * 4 символов + 1 символ под нулевой</span><br />
		<span class="remark">&apos; Функция записывает завершающий ноль</span><br />
		<span class="remark">&apos; Возвращает количество символов (без учёта завершающего нуля)</span><br />
		<span class="keyword">Declare</span> <span class="keyword">Function</span> Encode64( _<br />
		&t;&t;<span class="keyword">ByVal</span> sOut <span class="keyword">As</span> <span class="keyword">WString Ptr</span>, _<br />
		&t;&t;<span class="keyword">ByVal</span> sEncodedB <span class="keyword">As</span> <span class="keyword">UByte</span> <span class="keyword">Ptr</span>, _<br />
		&t;&t;<span class="keyword">ByVal</span> BytesCount <span class="keyword">As</span> <span class="keyword">Integer</span> _<br />
		)<span class="keyword">As</span> <span class="keyword">Integer</span><br />
		<br />
		<span class="remark">&apos; Дешифрует из base64 в массив байт</span><br />
		<span class="remark">&apos; b — указатель на буфер, куда будет записан результат дешифровки</span><br />
		<span class="remark">&apos; s — указатель на base64‐строку</span><br />
		<span class="remark">&apos; Возвращает количество записанных в буфер байт</span><br />
		<span class="remark">&apos; Размер буфера должен быть достаточным для записи в него данных</span><br />
		<span class="keyword">Declare</span> <span class="keyword">Function</span> Decode64( _<br />
		&t;&t;<span class="keyword">ByVal</span> b <span class="keyword">As</span> <span class="keyword">UByte</span> <span class="keyword">Ptr</span>, _<br />
		&t;&t;<span class="keyword">ByVal</span> s <span class="keyword">As</span> <span class="keyword">WString Ptr</span> _<br />
		)<span class="keyword">As</span> <span class="keyword">Integer</span>
	</code></p>

	<p>Файл base64.bas:</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
		<span class="preprocessor">#include once &quot;base64.bi&quot;</span><br />
		<br />
		<span class="keyword">Function</span> E0(<span class="keyword">ByVal</span> v1 <span class="keyword">As</span> <span class="datatype">UByte</span>)<span class="keyword">As</span> <span class="datatype">UByte</span><br />
			&t;<span class="remark">&apos; Получить шесть левых бит числа</span><br />
			&t;<span class="keyword">Return</span> v1 <span class="keyword">Shr</span> 2<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> E1(<span class="keyword">ByVal</span> v1 <span class="keyword">As</span> <span class="datatype">UByte</span>, <span class="keyword">ByVal</span> v2 <span class="keyword">As</span> <span class="datatype">UByte</span>)<span class="keyword">As</span> <span class="datatype">UByte</span><br />
			&t;<span class="remark">&apos; Получить два правых бита первого числа и четыре левых бита второго числа</span><br />
			&t;<span class="keyword">Return</span> ((v1 <span class="keyword">And</span> &amp;b00000011) <span class="keyword">Shl</span> 4) + (v2 <span class="keyword">Shr</span> 4)<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> E2(<span class="keyword">ByVal</span> v2 <span class="keyword">As</span> <span class="datatype">UByte</span>, <span class="keyword">ByVal</span> v3 <span class="keyword">As</span> <span class="datatype">UByte</span>)<span class="keyword">As</span> <span class="datatype">UByte</span><br />
			&t;<span class="remark">&apos; Получить четыре правых бита первого числа и два левых бита второго числа</span><br />
			&t;<span class="keyword">Return</span> ((v2 <span class="keyword">And</span> &amp;b00001111) <span class="keyword">Shl</span> 2) + (v3 <span class="keyword">Shr</span> 6)<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> E3(<span class="keyword">ByVal</span> v3 <span class="keyword">As</span> <span class="datatype">UByte</span>)<span class="keyword">As</span> <span class="datatype">UByte</span><br />
			&t;<span class="remark">&apos; Получить шесть правых бит числа</span><br />
			&t;<span class="keyword">Return</span> v3 <span class="keyword">And</span> &amp;b00111111<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> Encode64(<span class="keyword">ByVal</span> sOut <span class="keyword">As</span> <span class="datatype">WString Ptr</span>, <span class="keyword">ByVal</span> sEncodedB <span class="keyword">As</span> <span class="datatype">UByte Ptr</span>, <span class="keyword">ByVal</span> BytesCount <span class="keyword">As</span> <span class="datatype">Integer</span>)<span class="keyword">As</span> <span class="datatype">Integer</span><br />
			&t;<span class="keyword">Dim</span> j <span class="keyword">As</span> <span class="datatype">Integer</span> = 0<br />
			&t;<span class="keyword">Dim</span> k <span class="keyword">As</span> <span class="datatype">Integer</span> = 0<br />
			&t;<span class="remark">&apos; Количество байт, не умещающихся в тройку байт</span><br />
			&t;<span class="keyword">Dim</span> ELM3 <span class="keyword">As</span> <span class="datatype">Integer</span> = BytesCount <span class="keyword">Mod</span> 3<br />
			&t;<span class="remark">&apos; Идти через каждые три байта</span><br />
			&t;<span class="keyword">For</span> j = 0 <span class="keyword">To</span> BytesCount - ELM3 - 1 <span class="keyword">Step</span> 3<br />
			&t;&t;sOut[k + 0] = (@B64 + E0(sEncodedB[j + 0]))[0]<br />
			&t;&t;sOut[k + 1] = (@B64 + E1(sEncodedB[j + 0], sEncodedB[j + 1]))[0]<br />
			&t;&t;sOut[k + 2] = (@B64 + E2(sEncodedB[j + 1], sEncodedB[j + 2]))[0]<br />
			&t;&t;sOut[k + 3] = (@B64 + E3(sEncodedB[j + 2]))[0]<br />
			&t;&t;k += 4<br />
			&t;<span class="keyword">Next</span><br />
			<br />
			&t;<span class="keyword">Select</span> <span class="keyword">Case</span> ELM3<br />
			&t;&t;<span class="keyword">Case</span> 1<br />
			&t;&t;&t;sOut[k + 0] = (@B64 + E0(sEncodedB[j + 0]))[0]<br />
			&t;&t;&t;sOut[k + 1] = (@B64 + E1(sEncodedB[j + 0], sEncodedB[j + 1]))[0]<br />
			&t;&t;&t;sOut[k + 2] = &amp;h3D<br />
			&t;&t;&t;sOut[k + 3] = &amp;h3D<br />
			&t;&t;&t;k += 4<br />
			&t;&t;<span class="keyword">Case</span> 2<br />
			&t;&t;&t;sOut[k + 0] = (@B64 + E0(sEncodedB[j + 0]))[0]<br />
			&t;&t;&t;sOut[k + 1] = (@B64 + E1(sEncodedB[j + 0], sEncodedB[j + 1]))[0]<br />
			&t;&t;&t;sOut[k + 2] = (@B64 + E2(sEncodedB[j + 1], sEncodedB[j + 2]))[0]<br />
			&t;&t;&t;sOut[k + 3] = &amp;h3D<br />
			&t;&t;&t;k += 4<br />
			&t;<span class="keyword">End Select</span><br />
			&t;<span class="remark">&apos; Поставить завершающий ноль</span><br />
			&t;sOut[k] = 0<br />
			&t;<span class="keyword">Return</span> k<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> GetBase64Index(<span class="keyword">ByVal</span> sChar <span class="keyword">As</span> <span class="datatype">Integer</span>)<span class="keyword">As</span> <span class="datatype">Integer</span><br />
			&t;<span class="keyword">If</span> sChar = 0 <span class="keyword">Then</span><br />
			&t;&t;<span class="keyword">Return</span> -1<br />
			&t;<span class="keyword">End If</span><br />
			&t;<span class="keyword">Dim</span> w <span class="keyword">As</span> <span class="datatype">WString Ptr</span> = StrChr(@B64, sChar)<br />
			&t;<span class="keyword">If</span> w = 0 <span class="keyword">Then</span><br />
			&t;&t;<span class="keyword">Return</span> -1<br />
			&t;<span class="keyword">End If</span><br />
			&t;<span class="keyword">Return</span> w - @B64<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="remark">&apos; Пропускаем все символы не из набора</span><br />
		<span class="keyword">Function</span> SkipWrongChar(<span class="keyword">ByVal</span> s <span class="keyword">As</span> <span class="datatype">WString Ptr</span>)<span class="keyword">As</span> <span class="datatype">Integer</span><br />
			&t;<span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="datatype">Integer</span> = 0<br />
			&t;<span class="keyword">Dim</span> sChar <span class="keyword">As</span> <span class="datatype">Integer</span> = s[i]<br />
			&t;<span class="keyword">Do</span> <span class="keyword">Until</span> sChar = 0<br />
			&t;&t;<span class="keyword">If</span> GetBase64Index(sChar) &lt;&gt; -1 <span class="keyword">Then</span><br />
			&t;&t;&t;<span class="keyword">Exit Do</span><br />
			&t;&t;<span class="keyword">End If</span><br />
			&t;&t;i += 1<br />
			&t;&t;sChar = s[i]<br />
			&t;<span class="keyword">Loop</span><br />
			&t;<span class="keyword">Return</span> i<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> CalculateString(<span class="keyword">ByVal</span> b <span class="keyword">As</span> <span class="datatype">UByte Ptr</span>, <span class="keyword">ByVal</span> BytesCount <span class="keyword">As</span> <span class="datatype">Integer</span>, <span class="keyword">ByVal</span> w1 <span class="keyword">As</span> <span class="datatype">Integer</span>, <span class="keyword">ByVal</span> w2 <span class="keyword">As</span> <span class="datatype">Integer</span>, <span class="keyword">ByVal</span> w3 <span class="keyword">As</span> <span class="datatype">Integer</span>, <span class="keyword">ByVal</span> w4 <span class="keyword">As</span> <span class="datatype">Integer</span>)<span class="keyword">As</span> <span class="datatype">Integer</span><br />
			&t;<span class="keyword">If</span> w2 &gt; -1 <span class="keyword">Then</span><br />
			&t;&t;b[BytesCount] = (w1 * 4 + w2 \ 16) <span class="keyword">And</span> 255<br />
			&t;&t;BytesCount += 1<br />
			&t;<span class="keyword">End If</span><br />
			&t;<span class="keyword">If</span> w3 &gt; -1 <span class="keyword">Then</span><br />
			&t;&t;b[BytesCount] = (w2 * 16 + w3 \ 4) <span class="keyword">And</span> 255<br />
			&t;&t;BytesCount += 1<br />
			&t;<span class="keyword">End If</span><br />
			&t;<span class="keyword">If</span> w4 &gt; -1 <span class="keyword">Then</span><br />
			&t;&t;b[BytesCount] = (w3 * 64 + w4) <span class="keyword">And</span> 255<br />
			&t;&t;BytesCount += 1<br />
			&t;<span class="keyword">End If</span><br />
			&t;<span class="keyword">Return</span> BytesCount<br />
		<span class="keyword">End Function</span><br />
		<br />
		<span class="keyword">Function</span> Decode64(<span class="keyword">ByVal</span> b <span class="keyword">As</span> <span class="datatype">UByte Ptr</span>, <span class="keyword">ByVal</span> s <span class="keyword">As</span> <span class="datatype">WString Ptr</span>)<span class="keyword">As</span> <span class="datatype">Integer</span><br />
			&t;<span class="keyword">Dim</span> BytesCount <span class="keyword">As</span> <span class="datatype">Integer</span> = 0<br />
			&t;<span class="keyword">Dim</span> length <span class="keyword">As</span> <span class="datatype">Integer</span> = <span class="keyword">Len</span>(*s)<br />
			&t;<span class="keyword">For</span> i <span class="keyword">As</span> <span class="datatype">Integer</span> = 0 <span class="keyword">To</span> length - 1 <span class="keyword">Step</span> 4<br />
			&t;&t;<span class="keyword">Dim</span> ww <span class="keyword">As</span> <span class="datatype">Integer</span> = <span class="keyword">Any</span><br />
			&t;&t;<span class="remark">&apos; Необходимо пропустить все символы не из набора</span><br />
			&t;&t;i += SkipWrongChar(s[i + 0])<br />
			&t;&t;<span class="keyword">If</span> i &gt;= length - 0 <span class="keyword">Then</span><br />
			&t;&t;&t;<span class="keyword">Return</span> BytesCount<br />
			&t;&t;<span class="keyword">End If</span><br />
			&t;&t;ww = s[i + 0]<br />
			&t;&t;<span class="keyword">Dim</span> w1 <span class="keyword">As</span> <span class="datatype">Integer</span> = GetBase64Index(ww)<br />
			<br />
			&t;&t;i += SkipWrongChar(s[i + 1])<br />
			&t;&t;<span class="keyword">If</span> i &gt;= length - 1 <span class="keyword">Then</span><br />
			&t;&t;&t;<span class="keyword">Return</span> CalculateString(b, BytesCount, w1, 0, 0, 0)<br />
			&t;&t;<span class="keyword">End If</span><br />
			&t;&t;ww = s[i + 1]<br />
			&t;&t;<span class="keyword">Dim</span> w2 <span class="keyword">As</span> <span class="datatype">Integer</span> = GetBase64Index(ww)<br />
			<br />
			&t;&t;i += SkipWrongChar(s[i + 2])<br />
			&t;&t;<span class="keyword">If</span> i &gt;= length - 2 <span class="keyword">Then</span><br />
			&t;&t;&t;<span class="keyword">Return</span> CalculateString(b, BytesCount, w1, w2, 0, 0)<br />
			&t;&t;<span class="keyword">End If</span><br />
			&t;&t;ww = s[i + 2]<br />
			&t;&t;<span class="keyword">Dim</span> w3 <span class="keyword">As</span> <span class="datatype">Integer</span> = GetBase64Index(ww)<br />
			<br />
			&t;&t;i += SkipWrongChar(s[i + 3])<br />
			&t;&t;<span class="keyword">If</span> i &gt;= length - 3 <span class="keyword">Then</span><br />
			&t;&t;&t;<span class="keyword">Return</span> CalculateString(b, BytesCount, w1, w2, w3, 0)<br />
			&t;&t;<span class="keyword">End If</span><br />
			&t;&t;ww = s[i + 3]<br />
			&t;&t;<span class="keyword">Dim</span> w4 <span class="keyword">As</span> <span class="datatype">Integer</span> = GetBase64Index(ww)<br />
			<br />
			&t;&t;BytesCount = CalculateString(b, BytesCount, w1, w2, w3, w4)<br />
			&t;<span class="keyword">Next</span><br />
			&t;<span class="keyword">Return</span> BytesCount<br />
		<span class="keyword">End Function</span>
	</code></p>


	<h2><a id="c4">Использование</a></h2>

	<p>Функция Encode64 кодирует массив байт в base64‐строку. Для этого ей нужно передать указатель буфер под результирующую строку, указатель на массив байт и размер массива.</p>

	<p class="codebox"><span>Код</span> <span>FreeBASIC</span><br /><code>
	<span class="preprocessor">#ifndef unicode</span><br />
	<span class="preprocessor">#define unicode</span><br />
	<span class="preprocessor">#endif</span><br />
	<span class="remark">&apos; Для преобразования строки из utf-16 в utf-8</span><br />
	<span class="preprocessor">#include once &quot;windows.bi&quot;</span><br />
	<br />
	<span class="keyword">Const</span> BufferLength <span class="keyword">As</span> <span class="keyword">Integer</span> = 1024<br />
	<span class="keyword">Const</span> StringToConvert = <span class="string">&quot;Всем привет! Это сообщение будет закодировано.&quot;</span><br />
	<br />
	<span class="remark">&apos; Строка, куда будет записана base64‐строка, плюс один символ под нулевой</span><br />
	<span class="keyword">Dim</span> base64 <span class="keyword">As</span> <span class="keyword">WString</span> * (BufferLength + 1) = <span class="keyword">Any</span><br />
	<br />
	<span class="remark">&apos; Массив байт</span><br />
	<span class="keyword">Dim</span> bytes(BufferLength * <span class="keyword">SizeOf</span>(<span class="keyword">WString</span>)) <span class="keyword">As</span> <span class="keyword">UByte</span> = <span class="keyword">Any</span><br />
	<br />
	<span class="remark">&apos; Нужно получить из строки массив байт</span><br />
	<span class="remark">&apos; Для этого её нужно преобразовать в utf-8</span><br />
	<span class="keyword">Dim</span> BytesCount <span class="keyword">As</span> <span class="keyword">Integer</span> = WideCharToMultiByte(CP_UTF8, 0, @StringToConvert, -1, @bytes(0), BufferLength * <span class="keyword">SizeOf</span>(<span class="keyword">WString</span>), 0, 0) - 1<br />
	<br />
	<span class="remark">&apos; Закодировать массив байт в bas64</span><br />
	Encode64(@base64, @bytes(0), BytesCount)<br />
	<span class="keyword">Print</span> base64<br />
	<br />
	<span class="remark">&apos; Преобразовать из base64 в массив байт</span><br />
	BytesCount = Decode64(@bytes(0), @base64)<br />
	<br />
	<span class="remark">&apos; Из массива байт в строку, результат будет в base64</span><br />
	bytes(BytesCount) = 0<br />
	MultiByteToWideChar(CP_UTF8, 0, @bytes(0), -1, base64, BufferLength)<br />
	<span class="keyword">Print</span> base64<br />
	</code></p>

	<p>В примере используются функции <code>WideCharToMultiByte</code> и <code>MultiByteToWideChar</code> для преобразования строки в массив байт и обратно. Если у тебя есть уже заранее оформленный массив байт, например, данные файла, то эти функции использовать не нужно. В качестве домашнего задания предлагаю написать простую утилиту, кодирующую и декодирующую любые файлы в base64.</p>

	<h2>Поделись ссылочкой в социальных сетях</h2>
	<div id="vk_share_button"></div>

</main>

<hr />

<footer>
	<p>Сайт создан по технологии XHTML</p>
	<p>
		<span id="pLiveInternet"></span>
		<a href="http://wscatalog.ru/dir/programmirovanie-na-yazyke-freebasic" title="Сайт есть в Каталоге">
			<img width="88" height="31" src="http://wscatalog.ru/knopka.png" alt="Логотип wscatalog.ru" />
		</a>
		<a href="http://gluci.ru/dir/freebasic-na-russkom" title="Необычный Каталог Сайтов">
			<img width="88" height="31" src="http://gluci.ru/88x31.png" alt="Логотип Глюки" />
		</a> 
	</p>
</footer>

<script type="text/javascript" src="https://vk.com/js/api/share.js?93" charset="windows-1251"></script>
<script type="text/javascript">var docUrl=document.URL.toString();document.getElementById("vk_share_button").innerHTML=VK.Share.button(docUrl, {type: "round"});</script>


<script type="text/javascript">var idL=document.getElementById("pLiveInternet");var idA=document.createElement("a");idA.href="//www.liveinternet.ru/stat/freebasic.su";idA.title="Счётчик посещений LiveInternet";var idImg=document.createElement("img");idImg.src="//counter.yadro.ru/hit?t44."+Math.round(1+18*Math.random())+";r"+escape(document.referrer)+((typeof(screen)=="undefined")?"":";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?screen.colorDepth:screen.pixelDepth))+";u"+escape(docUrl)+";"+Math.random();idImg.alt="Логотип LiveInternet";idA.appendChild(idImg);idL.appendChild(idA);</script>

</body></html>